<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="referrer" content="strict-origin">
    <meta name="robots" content="index, follow">
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline'; 
                   style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; 
                   font-src 'self' https://fonts.gstatic.com; 
                   img-src 'self' data: https://*.githubusercontent.com https://img.shields.io https://komarev.com https://github-readme-activity-graph.vercel.app https://nirzak-streak-stats.vercel.app https://github-readme-stats.vercel.app https://github-profile-summary-cards.vercel.app https://vercel.app https://vercel.live;
                   frame-src 'self' https://transformers.gerivan.me https://*.githubusercontent.com;">	
	
	<!-- Favicon -->
	<link rel="icon" type="image/png" href="https://transformers.gerivan.me/web-app-manifest-784x910.png" sizes="784x910">
	<link rel="icon" type="image/x-icon" href="https://transformers.gerivan.me/favicon.ico">
	<link rel="shortcut icon" href="https://transformers.gerivan.me/favicon.ico">
	<link rel="apple-touch-icon" sizes="256x256" href="https://transformers.gerivan.me/apple-touch-icon-256x256.png">
	<link rel="manifest" href="https://transformers.gerivan.me/site.webmanifest">	

	<!-- Manifest -->
	<link rel="manifest" href="/site.webmanifest">
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; frame-src https://transformers.gerivan.me;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="ALLOW-FROM https://transformers.gerivan.me">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">

    <!-- Meta tags for PWA -->
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="description" content="Gerivan Costa - Developer passionate about security, science, and creativity">		
    <title>CYBER NEURAL NETWORK - DUAL MODE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">    	
	
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
            -webkit-touch-callout: none; /* Disable callout on long press */
        }
        
        /* Body styling with cyber theme */
        body {
            background-color: #0a0a16;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 255, 255, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 100, 0, 0.05) 0%, transparent 20%);
            touch-action: manipulation; /* Improve touch responsiveness */
        }
        
        /* Main container */
        .container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        /* Header section */
        .header {
            text-align: center;
            padding: 20px;
            z-index: 10;
            position: relative;
        }
        
        /* Main title styling */
        h1 {
            font-size: clamp(1.8rem, 6vw, 3.5rem);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 10px;
            color: #39ff14; /* Neon green */
        }
        
        /* Subtitle styling */
        .subtitle {
            font-size: clamp(1rem, 3.5vw, 1.4rem);
            font-weight: bold;
            color: #ff6600; /* Orange */
            letter-spacing: 2px;
            margin-bottom: 15px; /* Added margin for spacing */
        }
        
        /* Canvas container for neural network visualization */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        
        /* Canvas element */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Controls panel */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 20, 30, 0.85);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            z-index: 10;
            width: 300px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        /* Control group styling */
        .control-group {
            margin-bottom: 15px;
        }
        
        /* Label styling */
        label {
            display: block;
            margin-bottom: 5px;
            color: #ff6600;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        /* Slider container */
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        /* Range input styling */
        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #00ffff, #ff6600);
            border-radius: 5px;
            outline: none;
        }
        
        /* Slider thumb styling */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        /* Value display styling */
        .value-display {
            width: 40px;
            text-align: center;
            margin-left: 10px;
            color: #ffffff;
            font-weight: bold;
        }
        
        /* Node count display - UPDATED FOR DESKTOP */
        .node-count {
            position: relative;
            display: inline-block;
            background-color: transparent; /* Transparent background */
            padding: 8px 15px; /* Reduced padding for smaller size */
            border-radius: 5px;
            border: 1px solid #00ffff;
            z-index: 10;
            color: #ff6600;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem; /* Slightly smaller font */
            margin: 0 auto; /* Center alignment */
        }
        
        /* Reset button styles */
        .reset-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: linear-gradient(to right, #39ff14, #00ffff);
            border: none;
            border-radius: 5px;
            color: #0a0a16;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
        }
        
        /* Mode selector buttons */
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-button {
            flex: 1;
            padding: 10px;
            background: rgba(0, 20, 30, 0.7);
            border: 1px solid #00ffff;
            border-radius: 5px;
            color: #00ffff;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mode-button.active {
            background: linear-gradient(to right, #39ff14, #00ffff);
            color: #0a0a16;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.8);
        }
        
        /* Project links section */
        .card {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 20, 30, 0.85);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            z-index: 10;
            width: 300px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        /* Project repository title */
        .card h2 {
            color: #ff6600; /* Orange color as requested */
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Button group for project links */
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* Project link buttons */
        .btn-group button {
            padding: 10px;
            background: linear-gradient(to right, #39ff14, #00ffff);
            border: none;
            border-radius: 5px;
            color: #0a0a16;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            width: 100%;
        }
        
        /* Footer styling */
        footer {
            position: absolute;
            bottom: 0;
            width: 100%;
            padding: 10px;
            text-align: center;
            z-index: 5;
        }
        
        /* Footer text styling - Updated to White (#FFFFFF) */
        footer p {
            color: #FFFFFF; /* White ice as requested */
            font-weight: bold;
            margin: 5px 0;
        }
        
        /* Scan line animation */
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(to right, transparent, #00ffff, transparent);
            animation: scan 5s linear infinite;
            z-index: 5;
        }
        
        /* Scan animation keyframes */
        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }
        
        /* Binary rain container */
        .binary-rain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.1;
        }
        
        /* Binary digit styling */
        .binary-digit {
            position: absolute;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            animation: fall linear infinite;
        }
        
        /* Binary rain animation */
        @keyframes fall {
            to {
                transform: translateY(100vh);
            }
        }
        
        /* Toggle buttons for mobile */
        .toggle-buttons {
            display: none;
            position: fixed;
            bottom: 70px; /* Increased from 10px to avoid footer overlap */
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            gap: 10px;
        }
        
        .toggle-btn {
            padding: 8px 15px;
            background: rgba(0, 20, 30, 0.9);
            border: 1px solid #00ffff;
            border-radius: 5px;
            color: #00ffff;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        /* Touch gesture indicator for mobile */
        .touch-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(57, 255, 20, 0.5);
            pointer-events: none;
            z-index: 15;
            transform: translate(-50%, -50%);
            display: none;
            animation: pulse 0.5s ease-out;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            /* Adjust header spacing for mobile */
            .header {
                padding-bottom: 60px;
            }
            
            /* Move mode selector below subtitle on mobile */
            .node-count {
                position: relative;
                top: auto;
                right: auto;
                margin: 10px auto;
                width: 90%;
                text-align: center;
                background-color: transparent; /* Make background transparent */
                border: 1px solid #00ffff;
            }
            
            /* Adjust controls and card positioning for mobile */
            .controls, .card {
                width: calc(100vw - 40px);
                left: 20px;
                right: 20px;
            }
            
            /* Position controls higher to avoid toggle buttons */
            .controls {
                bottom: 140px; /* Increased to avoid toggle buttons */
            }
            
            /* Position card higher to avoid toggle buttons */
            .card {
                bottom: 140px; /* Increased to avoid toggle buttons */
            }
            
            /* Show toggle buttons on mobile */
            .toggle-buttons {
                display: flex;
            }
            
            /* Hide controls and card by default on mobile */
            .controls.hidden, .card.hidden {
                transform: translateY(100px);
                opacity: 0;
                pointer-events: none;
            }
            
            /* Adjust footer for mobile - increased padding and font size */
            footer {
                padding: 15px 5px; /* Increased padding */
                background-color: rgba(0, 10, 20, 0.8); /* Added background for better visibility */
            }
            
            footer p {
                font-size: 0.85rem; /* Slightly larger font */
                margin: 3px 0;
            }
        }
        
        /* Desktop-specific adjustments */
        @media (min-width: 769px) {
            /* Position mode selector inline with subtitle */
            .node-count {
                position: relative;
                display: inline-block;
                top: auto;
                right: auto;
                margin: 0 0 0 20px; /* Margin to separate from subtitle */
                width: auto;
                text-align: center;
                background-color: transparent; /* Make background transparent */
                border: 1px solid #00ffff;
                vertical-align: middle; /* Align with subtitle */
            }
            
            /* Header container for proper alignment */
            .header {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            /* Subtitle container for inline alignment with node-count */
            .subtitle-container {
                display: flex;
                align-items: center;
                justify-content: center;
                flex-wrap: wrap;
                gap: 15px;
                margin-bottom: 15px;
            }
        }
        
        /* Very small screens */
        @media (max-width: 480px) {
            .toggle-btn {
                padding: 6px 12px;
                font-size: 0.7rem;
            }
            
            footer p {
                font-size: 0.75rem;
            }
            
            /* Further adjust toggle buttons position for very small screens */
            .toggle-buttons {
                bottom: 75px;
            }
            
            /* Adjust control panel position for very small screens */
            .controls {
                bottom: 150px; /* Increased to avoid toggle buttons */
            }
            
            .card {
                bottom: 150px; /* Increased to avoid toggle buttons */
            }
        }
        
        /* Extra small screens */
        @media (max-width: 360px) {
            .toggle-buttons {
                flex-direction: column;
                bottom: 80px;
            }
            
            /* Adjust control panel position for extra small screens */
            .controls {
                bottom: 160px; /* Increased to avoid toggle buttons */
            }
            
            .card {
                bottom: 160px; /* Increased to avoid toggle buttons */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CYBER NEURAL NETWORK - DUAL MODE</h1>
            <!-- Container for subtitle and mode indicator for proper alignment -->
            <div class="subtitle-container">
                <div class="subtitle">INTERACTIVE NODE VISUALIZATION - DUAL MODE</div>
                <!-- Mode indicator positioned inline with subtitle -->
                <div class="node-count">
                    NODES: <span id="nodeCount">150</span> | MODE: <span id="modeIndicator">CYBER/TECH</span>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="networkCanvas"></canvas>
            <div class="scan-line"></div>
            <div class="binary-rain" id="binaryRain"></div>
            <!-- Touch gesture indicators for mobile -->
            <div id="touchIndicators"></div>
        </div>
        
        <div class="controls">
            <div class="mode-selector">
                <button class="mode-button active" id="cyberModeBtn">CYBER/TECH MODE</button>
                <button class="mode-button" id="complexModeBtn">COMPLEX MODE</button>
            </div>
            
            <div class="control-group">
                <label for="nodeIntensity">NODE INTENSITY</label>
                <div class="slider-container">
                    <input type="range" id="nodeIntensity" min="0" max="100" value="70">
                    <div class="value-display" id="nodeIntensityValue">70</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="pulseSpeed">PULSE SPEED</label>
                <div class="slider-container">
                    <input type="range" id="pulseSpeed" min="1" max="20" value="10">
                    <div class="value-display" id="pulseSpeedValue">10</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="nodeCountSlider">NODE COUNT</label>
                <div class="slider-container">
                    <input type="range" id="nodeCountSlider" min="50" max="500" value="150">
                    <div class="value-display" id="nodeCountValue">150</div>
                </div>
            </div>
            
            <button class="reset-button" id="resetButton">RESET VISUALIZATION</button>
        </div>
        
        <!-- Project Links -->
        <section class="card">
            <h2>PROJECT REPOSITORY</h2>
            <div class="btn-group">
                <button onclick="window.open('https://transformers.gerivan.me/', '_blank')">
                    HOME NEURAL NETWORK
                </button>
                <button onclick="window.open('https://github.com/gerivanc/transformers/blob/main/LICENSE', '_blank')">
                    LICENSE AGREEMENT
                </button>
            </div>
        </section>
        
        <!-- Toggle buttons for mobile -->
        <div class="toggle-buttons">
            <button class="toggle-btn" id="toggleControls">TOGGLE CONTROLS</button>
            <button class="toggle-btn" id="toggleCard">TOGGLE PROJECT</button>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>Copyright © 2025 Gerivan Costa dos Santos</p>
            <p>Cyber Neural Network Visualization - Dual Mode © 2025</p>
            <p>Secure Connection Established • Neural Network Active</p>
        </div>
    </footer>

    <script>
        // Neural Network Visualization
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Mode management
        let currentMode = 'cyber'; // 'cyber' or 'complex'
        
        // Node class for neural network visualization
        class Node {
            constructor(x, y, radius, color, mode) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.baseRadius = radius;
                this.color = color;
                this.pulseOffset = Math.random() * Math.PI * 2;
                this.pulsePhase = 0;
                this.mode = mode;
                // Add properties for touch interaction
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
            }
            
            // Update node properties for animation
            update(pulseSpeed) {
                this.pulsePhase += 0.01 * pulseSpeed * (this.mode === 'cyber' ? 1.5 : 1);
                this.radius = this.baseRadius + Math.sin(this.pulsePhase + this.pulseOffset) * 
                    (this.mode === 'cyber' ? 3 : 2);
            }
            
            // Draw node on canvas
            draw(ctx) {
                // Complex mode has glow effects
                if (this.mode === 'complex') {
                    // Draw glow effect
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, this.radius,
                        this.x, this.y, this.radius * 2
                    );
                    
                    if (this.color === 'green') {
                        gradient.addColorStop(0, 'rgba(57, 255, 20, 0.8)');
                        gradient.addColorStop(1, 'rgba(57, 255, 20, 0)');
                    } else if (this.color === 'cyan') {
                        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    } else if (this.color === 'orange') {
                        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    } else {
                        gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw inner glow for complex mode
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
                }
                
                // Draw node
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                // Set color based on node type
                if (this.color === 'green') {
                    ctx.fillStyle = '#39ff14';
                } else if (this.color === 'cyan') {
                    ctx.fillStyle = '#00ffff';
                } else if (this.color === 'orange') {
                    ctx.fillStyle = '#ff6600';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                
                ctx.fill();
            }
            
            // Check if point is inside node
            containsPoint(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy) <= this.radius;
            }
        }
        
        // Connection class for links between nodes
        class Connection {
            constructor(node1, node2, mode) {
                this.node1 = node1;
                this.node2 = node2;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.mode = mode;
            }
            
            // Update connection properties for animation
            update(pulseSpeed) {
                this.pulsePhase += 0.01 * pulseSpeed * (this.mode === 'cyber' ? 1.5 : 1);
            }
            
            // Draw connection on canvas
            draw(ctx) {
                const dx = this.node2.x - this.node1.x;
                const dy = this.node2.y - this.node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only draw connections for nearby nodes
                const maxDistance = this.mode === 'cyber' ? 150 : 200;
                if (distance > maxDistance) return;
                
                const pulse = Math.sin(this.pulsePhase) * 0.5 + 0.5;
                const alpha = (0.3 + pulse * 0.7) * (1 - distance / maxDistance);
                
                ctx.beginPath();
                ctx.moveTo(this.node1.x, this.node1.y);
                ctx.lineTo(this.node2.x, this.node2.y);
                
                // Complex mode has gradient connections
                if (this.mode === 'complex') {
                    // Determine connection color based on node colors
                    let color1, color2;
                    
                    if (this.node1.color === 'green') {
                        color1 = [57, 255, 20];
                    } else if (this.node1.color === 'cyan') {
                        color1 = [0, 255, 255];
                    } else if (this.node1.color === 'orange') {
                        color1 = [255, 100, 0];
                    } else {
                        color1 = [255, 0, 0];
                    }
                    
                    if (this.node2.color === 'green') {
                        color2 = [57, 255, 20];
                    } else if (this.node2.color === 'cyan') {
                        color2 = [0, 255, 255];
                    } else if (this.node2.color === 'orange') {
                        color2 = [255, 100, 0];
                    } else {
                        color2 = [255, 0, 0];
                    }
                    
                    // Create gradient for connection
                    const gradient = ctx.createLinearGradient(
                        this.node1.x, this.node1.y,
                        this.node2.x, this.node2.y
                    );
                    
                    gradient.addColorStop(0, `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, ${alpha})`);
                    gradient.addColorStop(1, `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, ${alpha})`);
                    
                    ctx.strokeStyle = gradient;
                } else {
                    // Cyber mode has simpler cyan connections
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                }
                
                ctx.lineWidth = 1 + pulse * (this.mode === 'cyber' ? 2 : 1);
                ctx.stroke();
            }
        }
        
        // Network class to manage nodes and connections
        class Network {
            constructor() {
                this.nodes = [];
                this.connections = [];
                this.nodeIntensity = 70;
                this.pulseSpeed = 10;
                this.nodeCount = 150;
                this.mode = 'cyber';
                // Add properties for interaction
                this.draggedNodes = new Map(); // Support for multiple dragged nodes (multitouch)
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                // Add properties for improved interaction
                this.interactionRadius = 300;
                this.interactionStrength = 2;
                this.lastInteractionTime = 0;
                this.interactionCooldown = 16; // ~60fps
                // Properties for gesture recognition
                this.pinchStartDistance = 0;
                this.pinchStartNodeCount = this.nodeCount;
                this.touchIndicators = document.getElementById('touchIndicators');
            }
            
            // Generate nodes and connections for the network
            generateNodes() {
                this.nodes = [];
                this.connections = [];
                
                for (let i = 0; i < this.nodeCount; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = 3 + Math.random() * 4;
                    
                    // Assign colors with distribution
                    const rand = Math.random();
                    let color;
                    if (rand < 0.35) {
                        color = 'green';
                    } else if (rand < 0.65) {
                        color = 'cyan';
                    } else if (rand < 0.85) {
                        color = 'orange';
                    } else {
                        color = 'red';
                    }
                    
                    this.nodes.push(new Node(x, y, radius, color, this.mode));
                }
                
                // Create connections between nearby nodes
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const dx = this.nodes[i].x - this.nodes[j].x;
                        const dy = this.nodes[i].y - this.nodes[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        const connectionChance = this.mode === 'cyber' ? 0.4 : 0.3;
                        const maxDistance = this.mode === 'cyber' ? 120 : 150;
                        
                        if (distance < maxDistance && Math.random() < connectionChance) {
                            this.connections.push(new Connection(this.nodes[i], this.nodes[j], this.mode));
                        }
                    }
                }
            }
            
            // Update all nodes and connections
            update() {
                for (const node of this.nodes) {
                    node.update(this.pulseSpeed);
                }
                
                for (const connection of this.connections) {
                    connection.update(this.pulseSpeed);
                }
            }
            
            // Draw the entire network
            draw() {
                // Clear canvas with a slight fade effect for trails
                ctx.fillStyle = this.mode === 'cyber' ? 'rgba(10, 10, 22, 0.05)' : 'rgba(10, 10, 22, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections first (so they appear behind nodes)
                for (const connection of this.connections) {
                    connection.draw(ctx);
                }
                
                // Draw nodes
                for (const node of this.nodes) {
                    node.draw(ctx);
                }
            }
            
            // Change mode and regenerate network
            setMode(mode) {
                this.mode = mode;
                this.generateNodes();
                document.getElementById('modeIndicator').textContent = 
                    mode === 'cyber' ? 'CYBER/TECH' : 'COMPLEX';
            }
            
            // Handle mouse/touch interaction with performance optimization
            handleInteraction(x, y, isDragging = false) {
                const now = Date.now();
                
                // Throttle interactions for better performance
                if (now - this.lastInteractionTime < this.interactionCooldown) {
                    return;
                }
                this.lastInteractionTime = now;
                
                // For mobile, only interact when dragging specific nodes
                if (this.isMobile && this.draggedNodes.size > 0) {
                    // Dragged nodes are handled in the touchmove event
                    return;
                }
                
                // For desktop, repel nodes from cursor with optimized calculation
                if (!this.isMobile) {
                    // Use a more subtle interaction for better user experience
                    const interactionStrength = this.interactionStrength * 0.7; // Reduced strength for smoother interaction
                    
                    for (const node of this.nodes) {
                        const dx = node.x - x;
                        const dy = node.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.interactionRadius && distance > 0) {
                            // Calculate repulsion force with inverse square falloff for smoother effect
                            const force = (this.interactionRadius - distance) / this.interactionRadius;
                            const repulsion = force * interactionStrength / distance;
                            
                            node.x += dx * repulsion;
                            node.y += dy * repulsion;
                            
                            // Constrain nodes to canvas
                            node.x = Math.max(node.radius, Math.min(canvas.width - node.radius, node.x));
                            node.y = Math.max(node.radius, Math.min(canvas.height - node.radius, node.y));
                        }
                    }
                }
            }
            
            // Find node at position (for mobile interaction)
            findNodeAt(x, y) {
                // Check nodes in reverse order (top-most nodes first)
                for (let i = this.nodes.length - 1; i >= 0; i--) {
                    if (this.nodes[i].containsPoint(x, y)) {
                        return this.nodes[i];
                    }
                }
                return null;
            }
            
            // Start dragging a node (for mobile multitouch)
            startDrag(touchId, x, y) {
                const node = this.findNodeAt(x, y);
                if (node) {
                    // Visual feedback for node selection
                    node.baseRadius *= 1.5; // Enlarge selected node
                    this.draggedNodes.set(touchId, node);
                    
                    // Create touch indicator
                    this.createTouchIndicator(x, y);
                }
            }
            
            // Update dragged node position (for mobile multitouch)
            updateDrag(touchId, x, y) {
                const node = this.draggedNodes.get(touchId);
                if (node) {
                    node.x = x;
                    node.y = y;
                    
                    // Constrain node to canvas
                    node.x = Math.max(node.radius, Math.min(canvas.width - node.radius, node.x));
                    node.y = Math.max(node.radius, Math.min(canvas.height - node.radius, node.y));
                    
                    // Update touch indicator
                    this.createTouchIndicator(x, y);
                }
            }
            
            // Stop dragging (for mobile multitouch)
            stopDrag(touchId) {
                const node = this.draggedNodes.get(touchId);
                if (node) {
                    // Restore original size
                    node.baseRadius /= 1.5;
                    this.draggedNodes.delete(touchId);
                }
            }
            
            // Create visual indicator for touch points
            createTouchIndicator(x, y) {
                if (!this.isMobile) return;
                
                const indicator = document.createElement('div');
                indicator.className = 'touch-indicator';
                indicator.style.left = x + 'px';
                indicator.style.top = y + 'px';
                this.touchIndicators.appendChild(indicator);
                
                // Remove indicator after animation
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 500);
            }
            
            // Handle pinch gesture for node count adjustment
            handlePinch(startDistance, endDistance) {
                if (this.pinchStartDistance === 0) {
                    this.pinchStartDistance = startDistance;
                    this.pinchStartNodeCount = this.nodeCount;
                }
                
                const scale = endDistance / this.pinchStartDistance;
                const newCount = Math.max(50, Math.min(500, Math.round(this.pinchStartNodeCount * scale)));
                
                if (newCount !== this.nodeCount) {
                    this.nodeCount = newCount;
                    this.generateNodes();
                    document.getElementById('nodeCount').textContent = this.nodeCount;
                    document.getElementById('nodeCountSlider').value = this.nodeCount;
                    document.getElementById('nodeCountValue').textContent = this.nodeCount;
                }
            }
            
            // Reset pinch gesture tracking
            resetPinch() {
                this.pinchStartDistance = 0;
                this.pinchStartNodeCount = this.nodeCount;
            }
        }
        
        // Create network instance
        const network = new Network();
        network.generateNodes();
        
        // UI Controls
        const nodeIntensitySlider = document.getElementById('nodeIntensity');
        const nodeIntensityValue = document.getElementById('nodeIntensityValue');
        const pulseSpeedSlider = document.getElementById('pulseSpeed');
        const pulseSpeedValue = document.getElementById('pulseSpeedValue');
        const nodeCountSlider = document.getElementById('nodeCountSlider');
        const nodeCountValue = document.getElementById('nodeCountValue');
        const resetButton = document.getElementById('resetButton');
        const cyberModeBtn = document.getElementById('cyberModeBtn');
        const complexModeBtn = document.getElementById('complexModeBtn');
        const toggleControlsBtn = document.getElementById('toggleControls');
        const toggleCardBtn = document.getElementById('toggleCard');
        const controlsPanel = document.querySelector('.controls');
        const cardPanel = document.querySelector('.card');
        
        // Update node intensity
        nodeIntensitySlider.addEventListener('input', function() {
            network.nodeIntensity = this.value;
            nodeIntensityValue.textContent = this.value;
        });
        
        // Update pulse speed
        pulseSpeedSlider.addEventListener('input', function() {
            network.pulseSpeed = this.value;
            pulseSpeedValue.textContent = this.value;
        });
        
        // Update node count
        nodeCountSlider.addEventListener('input', function() {
            network.nodeCount = parseInt(this.value);
            nodeCountValue.textContent = this.value;
            document.getElementById('nodeCount').textContent = this.value;
            network.generateNodes();
        });
        
        // Reset visualization
        resetButton.addEventListener('click', function() {
            network.generateNodes();
        });
        
        // Switch to cyber mode
        cyberModeBtn.addEventListener('click', function() {
            network.setMode('cyber');
            cyberModeBtn.classList.add('active');
            complexModeBtn.classList.remove('active');
        });
        
        // Switch to complex mode
        complexModeBtn.addEventListener('click', function() {
            network.setMode('complex');
            complexModeBtn.classList.add('active');
            cyberModeBtn.classList.remove('active');
        });
        
        // Toggle controls panel on mobile
        toggleControlsBtn.addEventListener('click', function() {
            controlsPanel.classList.toggle('hidden');
        });
        
        // Toggle card panel on mobile
        toggleCardBtn.addEventListener('click', function() {
            cardPanel.classList.toggle('hidden');
        });
        
        // Mouse interaction for desktop
        canvas.addEventListener('mousemove', function(e) {
            if (!network.isMobile) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                network.handleInteraction(x, y);
            }
        });

        // Reset button functionality
        document.getElementById('resetButton').addEventListener('click', function() {
            // Reset all sliders to default values
            document.getElementById('nodeIntensity').value = 70;
            document.getElementById('pulseSpeed').value = 10;
            document.getElementById('nodeCountSlider').value = 150;
            
            // Update network with default values
            network.nodeIntensity = 70;
            network.pulseSpeed = 10;
            network.nodeCount = 150;
            
            // Regenerate nodes
            network.generateNodes();
            
            // Update display values
            updateControlValues();
        });
        
        // Track mouse position
        canvas.addEventListener('mousemove', function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (isMouseDown) {
                network.handleInteraction(mouseX, mouseY, true);
            } else {
                network.handleInteraction(mouseX, mouseY, false);
            }
        });
        
        // Track mouse down
        canvas.addEventListener('mousedown', function(e) {
            isMouseDown = true;
            network.handleInteraction(mouseX, mouseY, true);
        });
        
        // Track mouse up
        canvas.addEventListener('mouseup', function() {
            isMouseDown = false;
        });
        
        // Touch interaction for mobile
        let activeTouches = new Map(); // Track active touches
        
        // Handle touch start
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault(); // Prevent default touch behavior
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const x = touch.clientX;
                const y = touch.clientY;
                
                // Store touch
                activeTouches.set(touch.identifier, { x, y });
                
                // Start dragging if we have a node at this position
                network.startDrag(touch.identifier, x, y);
            }
            
            // Handle pinch gesture if exactly two touches
            if (activeTouches.size === 2) {
                const touches = Array.from(activeTouches.values());
                const dx = touches[1].x - touches[0].x;
                const dy = touches[1].y - touches[0].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                network.handlePinch(distance, distance);
            }
        }, { passive: false });
        
        // Handle touch move
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault(); // Prevent default touch behavior
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const x = touch.clientX;
                const y = touch.clientY;
                
                // Update touch position
                activeTouches.set(touch.identifier, { x, y });
                
                // Update dragged node
                network.updateDrag(touch.identifier, x, y);
            }
            
            // Handle pinch gesture if exactly two touches
            if (activeTouches.size === 2) {
                const touches = Array.from(activeTouches.values());
                const dx = touches[1].x - touches[0].x;
                const dy = touches[1].y - touches[0].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                network.handlePinch(network.pinchStartDistance, distance);
            }
        }, { passive: false });
        
        // Handle touch end
        canvas.addEventListener('touchend', function(e) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                
                // Stop dragging
                network.stopDrag(touch.identifier);
                
                // Remove touch
                activeTouches.delete(touch.identifier);
            }
            
            // Reset pinch if less than two touches remain
            if (activeTouches.size < 2) {
                network.resetPinch();
            }
        });
        
        // Handle touch cancel
        canvas.addEventListener('touchcancel', function(e) {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                
                // Stop dragging
                network.stopDrag(touch.identifier);
                
                // Remove touch
                activeTouches.delete(touch.identifier);
            }
            
            // Reset pinch if less than two touches remain
            if (activeTouches.size < 2) {
                network.resetPinch();
            }
        });
        
        // Binary rain effect
        function createBinaryRain() {
            const binaryRain = document.getElementById('binaryRain');
            const digits = ['0', '1'];
            
            // Create initial binary digits
            for (let i = 0; i < 50; i++) {
                const digit = document.createElement('div');
                digit.className = 'binary-digit';
                digit.textContent = digits[Math.floor(Math.random() * digits.length)];
                digit.style.left = Math.random() * 100 + 'vw';
                digit.style.top = Math.random() * 100 + 'vh';
                digit.style.animationDuration = (Math.random() * 5 + 3) + 's';
                digit.style.opacity = Math.random() * 0.5 + 0.1;
                binaryRain.appendChild(digit);
            }
        }
        
        // Initialize binary rain
        createBinaryRain();
        
        // Animation loop
        function animate() {
            network.update();
            network.draw();
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Hide controls and card by default on mobile
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            controlsPanel.classList.add('hidden');
            cardPanel.classList.add('hidden');
        }
    </script>
</body>
</html>
